// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0649
#pragma warning disable 1522
#pragma warning disable 0414
#pragma warning disable 0219
#pragma warning disable 0109

namespace Quantum {
  using System;
  using System.Collections.Generic;
  using System.Runtime.InteropServices;
  using Photon.Deterministic;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Optional = Quantum.Inspector.OptionalAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  
  public enum TurnEndReason : int {
    Time,
    Skip,
    Play,
    Resolved,
  }
  public enum TurnStatus : int {
    Inactive,
    Active,
    Resolving,
  }
  public enum TurnType : int {
    Play,
    Countdown,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
  }
  public static unsafe partial class InputButtons_ext {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet1024 {
    public const Int32 SIZE = 128;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[16];
    public const Int32 BitsSize = 1024;
    public Int32 Length {
      get {
        return 1024;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet1024*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 1024, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet1024* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet1024* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet1024* set) {
      Native.Utils.Clear(&set->bits[0], 128);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet1024* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet1024 FromArray(UInt64[] values) {
      Assert.Always(16 == values.Length);
      BitSet1024 result = default;
      for (int i = 0; i < 16; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 1024);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 1024);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 128);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 37;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 16);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet1024*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 16);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet128* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet128* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet128* set) {
      Native.Utils.Clear(&set->bits[0], 16);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet128* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 41;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[1];
    public const Int32 BitsSize = 2;
    public Int32 Length {
      get {
        return 2;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 2, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet2* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet2* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet2* set) {
      Native.Utils.Clear(&set->bits[0], 8);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet2* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet2 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length);
      BitSet2 result = default;
      for (int i = 0; i < 1; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 43;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet2048* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet2048* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet2048* set) {
      Native.Utils.Clear(&set->bits[0], 256);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet2048* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 47;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet256* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet256* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet256* set) {
      Native.Utils.Clear(&set->bits[0], 32);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet256* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 53;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet4096* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet4096* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet4096* set) {
      Native.Utils.Clear(&set->bits[0], 512);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet4096* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 59;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private fixed UInt64 bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    [System.ObsoleteAttribute("Use instance Set method instead")]
    public static void Set(BitSet512* set, Int32 bit) {
      set->bits[bit/64] |= (1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance Clear method instead")]
    public static void Clear(BitSet512* set, Int32 bit) {
      set->bits[bit/64] &= ~(1UL<<(bit%64));
    }
    [System.ObsoleteAttribute("Use instance ClearAll method instead")]
    public static void ClearAll(BitSet512* set) {
      Native.Utils.Clear(&set->bits[0], 64);
    }
    [System.ObsoleteAttribute("Use instance IsSet method instead")]
    public static Boolean IsSet(BitSet512* set, Int32 bit) {
      return (set->bits[bit/64]&(1UL<<(bit%64))) != 0UL;
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 61;
        fixed (UInt64* p = bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.AssetRefAttribute(typeof(BallPoolSpec))]
  [System.SerializableAttribute()]
  public unsafe partial struct AssetRefBallPoolSpec : IEquatable<AssetRefBallPoolSpec>, IAssetRef<BallPoolSpec> {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetGuid Id;
    public override String ToString() {
      return AssetRef.ToString(Id);
    }
    public static implicit operator AssetRefBallPoolSpec(BallPoolSpec value) {
      var r = default(AssetRefBallPoolSpec);
      if (value != null) {
        r.Id = value.Guid;
      }
      return r;
    }
    public override Boolean Equals(Object obj) {
      return obj is AssetRefBallPoolSpec other && Equals(other);
    }
    public Boolean Equals(AssetRefBallPoolSpec other) {
      return Id.Equals(other.Id);
    }
    public static Boolean operator ==(AssetRefBallPoolSpec a, AssetRefBallPoolSpec b) {
      return a.Id == b.Id;
    }
    public static Boolean operator !=(AssetRefBallPoolSpec a, AssetRefBallPoolSpec b) {
      return a.Id != b.Id;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 67;
        hash = hash * 31 + Id.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AssetRefBallPoolSpec*)ptr;
        AssetGuid.Serialize(&p->Id, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.AssetRefAttribute(typeof(ConfigAssets))]
  [System.SerializableAttribute()]
  public unsafe partial struct AssetRefConfigAssets : IEquatable<AssetRefConfigAssets>, IAssetRef<ConfigAssets> {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetGuid Id;
    public override String ToString() {
      return AssetRef.ToString(Id);
    }
    public static implicit operator AssetRefConfigAssets(ConfigAssets value) {
      var r = default(AssetRefConfigAssets);
      if (value != null) {
        r.Id = value.Guid;
      }
      return r;
    }
    public override Boolean Equals(Object obj) {
      return obj is AssetRefConfigAssets other && Equals(other);
    }
    public Boolean Equals(AssetRefConfigAssets other) {
      return Id.Equals(other.Id);
    }
    public static Boolean operator ==(AssetRefConfigAssets a, AssetRefConfigAssets b) {
      return a.Id == b.Id;
    }
    public static Boolean operator !=(AssetRefConfigAssets a, AssetRefConfigAssets b) {
      return a.Id != b.Id;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 71;
        hash = hash * 31 + Id.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AssetRefConfigAssets*)ptr;
        AssetGuid.Serialize(&p->Id, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.AssetRefAttribute(typeof(GameConfig))]
  [System.SerializableAttribute()]
  public unsafe partial struct AssetRefGameConfig : IEquatable<AssetRefGameConfig>, IAssetRef<GameConfig> {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetGuid Id;
    public override String ToString() {
      return AssetRef.ToString(Id);
    }
    public static implicit operator AssetRefGameConfig(GameConfig value) {
      var r = default(AssetRefGameConfig);
      if (value != null) {
        r.Id = value.Guid;
      }
      return r;
    }
    public override Boolean Equals(Object obj) {
      return obj is AssetRefGameConfig other && Equals(other);
    }
    public Boolean Equals(AssetRefGameConfig other) {
      return Id.Equals(other.Id);
    }
    public static Boolean operator ==(AssetRefGameConfig a, AssetRefGameConfig b) {
      return a.Id == b.Id;
    }
    public static Boolean operator !=(AssetRefGameConfig a, AssetRefGameConfig b) {
      return a.Id != b.Id;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 73;
        hash = hash * 31 + Id.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AssetRefGameConfig*)ptr;
        AssetGuid.Serialize(&p->Id, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.AssetRefAttribute(typeof(TurnConfig))]
  [System.SerializableAttribute()]
  public unsafe partial struct AssetRefTurnConfig : IEquatable<AssetRefTurnConfig>, IAssetRef<TurnConfig> {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetGuid Id;
    public override String ToString() {
      return AssetRef.ToString(Id);
    }
    public static implicit operator AssetRefTurnConfig(TurnConfig value) {
      var r = default(AssetRefTurnConfig);
      if (value != null) {
        r.Id = value.Guid;
      }
      return r;
    }
    public override Boolean Equals(Object obj) {
      return obj is AssetRefTurnConfig other && Equals(other);
    }
    public Boolean Equals(AssetRefTurnConfig other) {
      return Id.Equals(other.Id);
    }
    public static Boolean operator ==(AssetRefTurnConfig a, AssetRefTurnConfig b) {
      return a.Id == b.Id;
    }
    public static Boolean operator !=(AssetRefTurnConfig a, AssetRefTurnConfig b) {
      return a.Id != b.Id;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 79;
        hash = hash * 31 + Id.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AssetRefTurnConfig*)ptr;
        AssetGuid.Serialize(&p->Id, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Quantum.AssetRefAttribute(typeof(UserMap))]
  [System.SerializableAttribute()]
  public unsafe partial struct AssetRefUserMap : IEquatable<AssetRefUserMap>, IAssetRef<UserMap> {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetGuid Id;
    public override String ToString() {
      return AssetRef.ToString(Id);
    }
    public static implicit operator AssetRefUserMap(UserMap value) {
      var r = default(AssetRefUserMap);
      if (value != null) {
        r.Id = value.Guid;
      }
      return r;
    }
    public override Boolean Equals(Object obj) {
      return obj is AssetRefUserMap other && Equals(other);
    }
    public Boolean Equals(AssetRefUserMap other) {
      return Id.Equals(other.Id);
    }
    public static Boolean operator ==(AssetRefUserMap a, AssetRefUserMap b) {
      return a.Id == b.Id;
    }
    public static Boolean operator !=(AssetRefUserMap a, AssetRefUserMap b) {
      return a.Id != b.Id;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 83;
        hash = hash * 31 + Id.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AssetRefUserMap*)ptr;
        AssetGuid.Serialize(&p->Id, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BallPoolPlayer {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public PlayerRef Ref;
    [FieldOffset(4)]
    public QBoolean StripedBalls;
    [FieldOffset(8)]
    public TurnData TurnStats;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 89;
        hash = hash * 31 + Ref.GetHashCode();
        hash = hash * 31 + StripedBalls.GetHashCode();
        hash = hash * 31 + TurnStats.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BallPoolPlayer*)ptr;
        PlayerRef.Serialize(&p->Ref, serializer);
        QBoolean.Serialize(&p->StripedBalls, serializer);
        Quantum.TurnData.Serialize(&p->TurnStats, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FPVector2 BallPosition;
    [FieldOffset(24)]
    public FPVector3 Direction;
    [FieldOffset(0)]
    public FP ForceBarMarkPos;
    public const int MAX_COUNT = 2;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 97;
        hash = hash * 31 + BallPosition.GetHashCode();
        hash = hash * 31 + Direction.GetHashCode();
        hash = hash * 31 + ForceBarMarkPos.GetHashCode();
        return hash;
      }
    }
    public static Input Read(FrameSerializer serializer) {
      Input i = new Input();
      Serialize(&i, serializer);
      return i;
    }
    public static void Write(FrameSerializer serializer, Input i) {
      Serialize(&i, serializer);
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
      }
      return false;
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
      }
      return false;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        FP.Serialize(&p->ForceBarMarkPos, serializer);
        FPVector2.Serialize(&p->BallPosition, serializer);
        FPVector3.Serialize(&p->Direction, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct TurnData {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public AssetRefTurnConfig ConfigRef;
    [FieldOffset(32)]
    public EntityRef Entity;
    [FieldOffset(0)]
    public Int32 Number;
    [FieldOffset(8)]
    public PlayerRef Player;
    [FieldOffset(12)]
    public TurnStatus Status;
    [FieldOffset(4)]
    public Int32 Ticks;
    [FieldOffset(16)]
    public TurnType Type;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 101;
        hash = hash * 31 + ConfigRef.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        hash = hash * 31 + Number.GetHashCode();
        hash = hash * 31 + Player.GetHashCode();
        hash = hash * 31 + (Int32)Status;
        hash = hash * 31 + Ticks.GetHashCode();
        hash = hash * 31 + (Int32)Type;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TurnData*)ptr;
        serializer.Stream.Serialize(&p->Number);
        serializer.Stream.Serialize(&p->Ticks);
        PlayerRef.Serialize(&p->Player, serializer);
        serializer.Stream.Serialize((Int32*)&p->Status);
        serializer.Stream.Serialize((Int32*)&p->Type);
        Quantum.AssetRefTurnConfig.Serialize(&p->ConfigRef, serializer);
        EntityRef.Serialize(&p->Entity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 776;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QBoolean CapturedEighthBall;
    [FieldOffset(120)]
    public TurnData CurrentTurn;
    [FieldOffset(48)]
    public FP DeltaTime;
    [FieldOffset(80)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(8)]
    public QBoolean HasFirstCaptured;
    [FieldOffset(12)]
    public QBoolean IsFirstTurn;
    [FieldOffset(32)]
    public AssetRefMap Map;
    [FieldOffset(56)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(480)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(40)]
    public BitSet2 PlayerLastConnectionState;
    [FieldOffset(16)]
    public QBoolean PlayerScoreThisTurn;
    [FieldOffset(160)]
    [FramePrinter.FixedArrayAttribute(typeof(BallPoolPlayer), 2)]
    private fixed Byte _Players_[96];
    [FieldOffset(20)]
    public QBoolean ReplaceWhiteBall;
    [FieldOffset(64)]
    public RNGSession RngSession;
    [FieldOffset(352)]
    public BitSet1024 Systems;
    [FieldOffset(0)]
    public Int32 TicksResolving;
    [FieldOffset(24)]
    public QBoolean WhiteBallFirstContact;
    [FieldOffset(256)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 2)]
    private fixed Byte _input_[96];
    public FixedArray<BallPoolPlayer> Players {
      get {
        fixed (byte* p = _Players_) { return new FixedArray<BallPoolPlayer>(p, 48, 2); }
      }
    }
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 48, 2); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 103;
        hash = hash * 31 + CapturedEighthBall.GetHashCode();
        hash = hash * 31 + CurrentTurn.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + HasFirstCaptured.GetHashCode();
        hash = hash * 31 + IsFirstTurn.GetHashCode();
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        hash = hash * 31 + PlayerScoreThisTurn.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(Players);
        hash = hash * 31 + ReplaceWhiteBall.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + TicksResolving.GetHashCode();
        hash = hash * 31 + WhiteBallFirstContact.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        serializer.Stream.Serialize(&p->TicksResolving);
        QBoolean.Serialize(&p->CapturedEighthBall, serializer);
        QBoolean.Serialize(&p->HasFirstCaptured, serializer);
        QBoolean.Serialize(&p->IsFirstTurn, serializer);
        QBoolean.Serialize(&p->PlayerScoreThisTurn, serializer);
        QBoolean.Serialize(&p->ReplaceWhiteBall, serializer);
        QBoolean.Serialize(&p->WhiteBallFirstContact, serializer);
        AssetRefMap.Serialize(&p->Map, serializer);
        Quantum.BitSet2.Serialize(&p->PlayerLastConnectionState, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.TurnData.Serialize(&p->CurrentTurn, serializer);
        FixedArray.Serialize(p->Players, serializer, StaticDelegates.SerializeBallPoolPlayer);
        FixedArray.Serialize(p->input, serializer, StaticDelegates.SerializeInput);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BallFields : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QBoolean InTable;
    [FieldOffset(0)]
    public Int32 Number;
    [FieldOffset(16)]
    public AssetRefBallPoolSpec Spec;
    [FieldOffset(24)]
    public FPVector2 Spin;
    [FieldOffset(8)]
    public QBoolean Striped;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 107;
        hash = hash * 31 + InTable.GetHashCode();
        hash = hash * 31 + Number.GetHashCode();
        hash = hash * 31 + Spec.GetHashCode();
        hash = hash * 31 + Spin.GetHashCode();
        hash = hash * 31 + Striped.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BallFields*)ptr;
        serializer.Stream.Serialize(&p->Number);
        QBoolean.Serialize(&p->InTable, serializer);
        QBoolean.Serialize(&p->Striped, serializer);
        Quantum.AssetRefBallPoolSpec.Serialize(&p->Spec, serializer);
        FPVector2.Serialize(&p->Spin, serializer);
    }
  }
  public unsafe partial class Frame {
    private ISignalOnBallPoolShot[] _ISignalOnBallPoolShotSystems;
    private ISignalOnBallPoolHitHole[] _ISignalOnBallPoolHitHoleSystems;
    private ISignalOnTurnEnded[] _ISignalOnTurnEndedSystems;
    private ISignalOnPlayCommandReceived[] _ISignalOnPlayCommandReceivedSystems;
    private ISignalOnSkipCommandReceived[] _ISignalOnSkipCommandReceivedSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    static partial void InitStaticGen() {
      ComponentTypeId.Setup(() => {
        ComponentTypeId.Add<Quantum.BallFields>(Quantum.BallFields.Serialize, null, null, ComponentFlags.None);
      });
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities);
      _ISignalOnBallPoolShotSystems = BuildSignalsArray<ISignalOnBallPoolShot>();
      _ISignalOnBallPoolHitHoleSystems = BuildSignalsArray<ISignalOnBallPoolHitHole>();
      _ISignalOnTurnEndedSystems = BuildSignalsArray<ISignalOnTurnEnded>();
      _ISignalOnPlayCommandReceivedSystems = BuildSignalsArray<ISignalOnPlayCommandReceived>();
      _ISignalOnSkipCommandReceivedSystems = BuildSignalsArray<ISignalOnSkipCommandReceived>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<Quantum.BallFields>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BallFields>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
    }
    public void SetPlayerInput(Int32 player, Input input) {
      if ((uint)player >= (uint)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->Direction = input.Direction;
      i->ForceBarMarkPos = input.ForceBarMarkPos;
      i->BallPosition = input.BallPosition;
    }
    public Input* GetPlayerInput(Int32 player) {
      if ((uint)player >= (uint)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    public unsafe partial struct FrameSignals {
      public void OnBallPoolShot(PlayerRef player) {
        var array = _f._ISignalOnBallPoolShotSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBallPoolShot(_f, player);
          }
        }
      }
      public void OnBallPoolHitHole(EntityRef ball) {
        var array = _f._ISignalOnBallPoolHitHoleSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnBallPoolHitHole(_f, ball);
          }
        }
      }
      public void OnTurnEnded(TurnData data, TurnEndReason reason) {
        var array = _f._ISignalOnTurnEndedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTurnEnded(_f, data, reason);
          }
        }
      }
      public void OnPlayCommandReceived(PlayerRef player, PlayCommandData data) {
        var array = _f._ISignalOnPlayCommandReceivedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnPlayCommandReceived(_f, player, data);
          }
        }
      }
      public void OnSkipCommandReceived(PlayerRef player, SkipCommandData data) {
        var array = _f._ISignalOnSkipCommandReceivedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnSkipCommandReceived(_f, player, data);
          }
        }
      }
    }
    public unsafe partial struct FrameEvents {
      public const Int32 EVENT_TYPE_COUNT = 18;
      public static Int32 GetParentEventID(Int32 eventID) {
        switch (eventID) {
          case EventTurnTypeChanged.ID: return EventTurnEvent.ID;
          case EventTurnStatusChanged.ID: return EventTurnEvent.ID;
          case EventTurnEnded.ID: return EventTurnEvent.ID;
          case EventTurnTimerReset.ID: return EventTurnEvent.ID;
          case EventTurnActivated.ID: return EventTurnEvent.ID;
          case EventPlayCommandReceived.ID: return EventCommandEvent.ID;
          case EventSkipCommandReceived.ID: return EventCommandEvent.ID;
          default: return -1;
        }
      }
      public static System.Type GetEventType(Int32 eventID) {
        switch (eventID) {
          case EventMessage.ID: return typeof(EventMessage);
          case EventRemoveBall.ID: return typeof(EventRemoveBall);
          case EventEndGame.ID: return typeof(EventEndGame);
          case EventReplaceBall.ID: return typeof(EventReplaceBall);
          case EventCueHitBall.ID: return typeof(EventCueHitBall);
          case EventBallsCollision.ID: return typeof(EventBallsCollision);
          case EventBallsHitWall.ID: return typeof(EventBallsHitWall);
          case EventBallsHitHole.ID: return typeof(EventBallsHitHole);
          case EventGameplayEnded.ID: return typeof(EventGameplayEnded);
          case EventTurnEvent.ID: return typeof(EventTurnEvent);
          case EventTurnTypeChanged.ID: return typeof(EventTurnTypeChanged);
          case EventTurnStatusChanged.ID: return typeof(EventTurnStatusChanged);
          case EventTurnEnded.ID: return typeof(EventTurnEnded);
          case EventTurnTimerReset.ID: return typeof(EventTurnTimerReset);
          case EventTurnActivated.ID: return typeof(EventTurnActivated);
          case EventCommandEvent.ID: return typeof(EventCommandEvent);
          case EventPlayCommandReceived.ID: return typeof(EventPlayCommandReceived);
          case EventSkipCommandReceived.ID: return typeof(EventSkipCommandReceived);
          default: throw new System.ArgumentOutOfRangeException("eventID");
        }
      }
      public EventMessage Message(String Header, String Text) {
        var ev = _f.Context.AcquireEvent<EventMessage>(EventMessage.ID);
        ev.Header = Header;
        ev.Text = Text;
        _f.AddEvent(ev);
        return ev;
      }
      public EventRemoveBall RemoveBall(Int32 Num) {
        var ev = _f.Context.AcquireEvent<EventRemoveBall>(EventRemoveBall.ID);
        ev.Num = Num;
        _f.AddEvent(ev);
        return ev;
      }
      public EventEndGame EndGame(PlayerRef Winner) {
        var ev = _f.Context.AcquireEvent<EventEndGame>(EventEndGame.ID);
        ev.Winner = Winner;
        _f.AddEvent(ev);
        return ev;
      }
      public EventReplaceBall ReplaceBall() {
        var ev = _f.Context.AcquireEvent<EventReplaceBall>(EventReplaceBall.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventCueHitBall CueHitBall() {
        var ev = _f.Context.AcquireEvent<EventCueHitBall>(EventCueHitBall.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventBallsCollision BallsCollision() {
        var ev = _f.Context.AcquireEvent<EventBallsCollision>(EventBallsCollision.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventBallsHitWall BallsHitWall() {
        var ev = _f.Context.AcquireEvent<EventBallsHitWall>(EventBallsHitWall.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventBallsHitHole BallsHitHole() {
        var ev = _f.Context.AcquireEvent<EventBallsHitHole>(EventBallsHitHole.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventGameplayEnded GameplayEnded() {
        if (_f.IsPredicted) return null;
        var ev = _f.Context.AcquireEvent<EventGameplayEnded>(EventGameplayEnded.ID);
        _f.AddEvent(ev);
        return ev;
      }
      public EventTurnTypeChanged TurnTypeChanged(TurnData Turn, TurnType PreviousType) {
        if (_f.IsPredicted) return null;
        var ev = _f.Context.AcquireEvent<EventTurnTypeChanged>(EventTurnTypeChanged.ID);
        ev.Turn = Turn;
        ev.PreviousType = PreviousType;
        _f.AddEvent(ev);
        return ev;
      }
      public EventTurnStatusChanged TurnStatusChanged(TurnData Turn, TurnStatus PreviousStatus) {
        if (_f.IsPredicted) return null;
        var ev = _f.Context.AcquireEvent<EventTurnStatusChanged>(EventTurnStatusChanged.ID);
        ev.Turn = Turn;
        ev.PreviousStatus = PreviousStatus;
        _f.AddEvent(ev);
        return ev;
      }
      public EventTurnEnded TurnEnded(TurnData Turn, TurnEndReason Reason) {
        if (_f.IsPredicted) return null;
        var ev = _f.Context.AcquireEvent<EventTurnEnded>(EventTurnEnded.ID);
        ev.Turn = Turn;
        ev.Reason = Reason;
        _f.AddEvent(ev);
        return ev;
      }
      public EventTurnTimerReset TurnTimerReset(TurnData Turn) {
        if (_f.IsPredicted) return null;
        var ev = _f.Context.AcquireEvent<EventTurnTimerReset>(EventTurnTimerReset.ID);
        ev.Turn = Turn;
        _f.AddEvent(ev);
        return ev;
      }
      public EventTurnActivated TurnActivated(TurnData Turn) {
        if (_f.IsPredicted) return null;
        var ev = _f.Context.AcquireEvent<EventTurnActivated>(EventTurnActivated.ID);
        ev.Turn = Turn;
        _f.AddEvent(ev);
        return ev;
      }
      public EventPlayCommandReceived PlayCommandReceived(PlayerRef Player, PlayCommandData Data) {
        var ev = _f.Context.AcquireEvent<EventPlayCommandReceived>(EventPlayCommandReceived.ID);
        ev.Player = Player;
        ev.Data = Data;
        _f.AddEvent(ev);
        return ev;
      }
      public EventSkipCommandReceived SkipCommandReceived(PlayerRef Player, SkipCommandData Data) {
        var ev = _f.Context.AcquireEvent<EventSkipCommandReceived>(EventSkipCommandReceived.ID);
        ev.Player = Player;
        ev.Data = Data;
        _f.AddEvent(ev);
        return ev;
      }
    }
    public unsafe partial struct FrameAssets {
      public BallPoolSpec BallPoolSpec(AssetRefBallPoolSpec assetRef) {
         return _f.FindAsset<BallPoolSpec>(assetRef.Id);
      }
      public ConfigAssets ConfigAssets(AssetRefConfigAssets assetRef) {
         return _f.FindAsset<ConfigAssets>(assetRef.Id);
      }
      public GameConfig GameConfig(AssetRefGameConfig assetRef) {
         return _f.FindAsset<GameConfig>(assetRef.Id);
      }
      public UserMap UserMap(AssetRefUserMap assetRef) {
         return _f.FindAsset<UserMap>(assetRef.Id);
      }
      public TurnConfig TurnConfig(AssetRefTurnConfig assetRef) {
         return _f.FindAsset<TurnConfig>(assetRef.Id);
      }
    }
  }
  public unsafe interface ISignalOnBallPoolShot : ISignal {
    void OnBallPoolShot(Frame f, PlayerRef player);
  }
  public unsafe interface ISignalOnBallPoolHitHole : ISignal {
    void OnBallPoolHitHole(Frame f, EntityRef ball);
  }
  public unsafe interface ISignalOnTurnEnded : ISignal {
    void OnTurnEnded(Frame f, TurnData data, TurnEndReason reason);
  }
  public unsafe interface ISignalOnPlayCommandReceived : ISignal {
    void OnPlayCommandReceived(Frame f, PlayerRef player, PlayCommandData data);
  }
  public unsafe interface ISignalOnSkipCommandReceived : ISignal {
    void OnSkipCommandReceived(Frame f, PlayerRef player, SkipCommandData data);
  }
  public unsafe partial class EventMessage : EventBase {
    public new const Int32 ID = 0;
    public String Header;
    public String Text;
    protected EventMessage(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventMessage() : 
        base(0, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 37;
        hash = hash * 31 + Header.GetHashCode();
        hash = hash * 31 + Text.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventRemoveBall : EventBase {
    public new const Int32 ID = 1;
    public Int32 Num;
    protected EventRemoveBall(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventRemoveBall() : 
        base(1, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 41;
        hash = hash * 31 + Num.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventEndGame : EventBase {
    public new const Int32 ID = 2;
    public PlayerRef Winner;
    protected EventEndGame(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventEndGame() : 
        base(2, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 43;
        hash = hash * 31 + Winner.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventReplaceBall : EventBase {
    public new const Int32 ID = 3;
    protected EventReplaceBall(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventReplaceBall() : 
        base(3, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 47;
        return hash;
      }
    }
  }
  public unsafe partial class EventCueHitBall : EventBase {
    public new const Int32 ID = 4;
    protected EventCueHitBall(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventCueHitBall() : 
        base(4, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 53;
        return hash;
      }
    }
  }
  public unsafe partial class EventBallsCollision : EventBase {
    public new const Int32 ID = 5;
    protected EventBallsCollision(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventBallsCollision() : 
        base(5, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 59;
        return hash;
      }
    }
  }
  public unsafe partial class EventBallsHitWall : EventBase {
    public new const Int32 ID = 6;
    protected EventBallsHitWall(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventBallsHitWall() : 
        base(6, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 61;
        return hash;
      }
    }
  }
  public unsafe partial class EventBallsHitHole : EventBase {
    public new const Int32 ID = 7;
    protected EventBallsHitHole(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventBallsHitHole() : 
        base(7, EventFlags.Server|EventFlags.Client) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 67;
        return hash;
      }
    }
  }
  public unsafe partial class EventGameplayEnded : EventBase {
    public new const Int32 ID = 8;
    protected EventGameplayEnded(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventGameplayEnded() : 
        base(8, EventFlags.Server|EventFlags.Client|EventFlags.Synced) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 71;
        return hash;
      }
    }
  }
  public abstract unsafe partial class EventTurnEvent : EventBase {
    public new const Int32 ID = 9;
    public TurnData Turn;
    protected EventTurnEvent(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 73;
        hash = hash * 31 + Turn.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventTurnTypeChanged : EventTurnEvent {
    public new const Int32 ID = 10;
    public TurnType PreviousType;
    protected EventTurnTypeChanged(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventTurnTypeChanged() : 
        base(10, EventFlags.Server|EventFlags.Client|EventFlags.Synced) {
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 79;
        hash = hash * 31 + Turn.GetHashCode();
        hash = hash * 31 + PreviousType.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventTurnStatusChanged : EventTurnEvent {
    public new const Int32 ID = 11;
    public TurnStatus PreviousStatus;
    protected EventTurnStatusChanged(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventTurnStatusChanged() : 
        base(11, EventFlags.Server|EventFlags.Client|EventFlags.Synced) {
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 83;
        hash = hash * 31 + Turn.GetHashCode();
        hash = hash * 31 + PreviousStatus.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventTurnEnded : EventTurnEvent {
    public new const Int32 ID = 12;
    public TurnEndReason Reason;
    protected EventTurnEnded(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventTurnEnded() : 
        base(12, EventFlags.Server|EventFlags.Client|EventFlags.Synced) {
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 89;
        hash = hash * 31 + Turn.GetHashCode();
        hash = hash * 31 + Reason.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventTurnTimerReset : EventTurnEvent {
    public new const Int32 ID = 13;
    protected EventTurnTimerReset(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventTurnTimerReset() : 
        base(13, EventFlags.Server|EventFlags.Client|EventFlags.Synced) {
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 97;
        hash = hash * 31 + Turn.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventTurnActivated : EventTurnEvent {
    public new const Int32 ID = 14;
    protected EventTurnActivated(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventTurnActivated() : 
        base(14, EventFlags.Server|EventFlags.Client|EventFlags.Synced) {
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 101;
        hash = hash * 31 + Turn.GetHashCode();
        return hash;
      }
    }
  }
  public abstract unsafe partial class EventCommandEvent : EventBase {
    public new const Int32 ID = 15;
    public PlayerRef Player;
    protected EventCommandEvent(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public new QuantumGame Game {
      get {
        return (QuantumGame)base.Game;
      }
      set {
        base.Game = value;
      }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 103;
        hash = hash * 31 + Player.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventPlayCommandReceived : EventCommandEvent {
    public new const Int32 ID = 16;
    public PlayCommandData Data;
    protected EventPlayCommandReceived(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventPlayCommandReceived() : 
        base(16, EventFlags.Server|EventFlags.Client) {
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 107;
        hash = hash * 31 + Player.GetHashCode();
        hash = hash * 31 + Data.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventSkipCommandReceived : EventCommandEvent {
    public new const Int32 ID = 17;
    public SkipCommandData Data;
    protected EventSkipCommandReceived(Int32 id, EventFlags flags) : 
        base(id, flags) {
    }
    public EventSkipCommandReceived() : 
        base(17, EventFlags.Server|EventFlags.Client) {
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 109;
        hash = hash * 31 + Player.GetHashCode();
        hash = hash * 31 + Data.GetHashCode();
        return hash;
      }
    }
  }
  public static unsafe partial class BitStreamExtensions {
    public static void Serialize(this IBitStream stream, ref AssetRefBallPoolSpec value) {
      stream.Serialize(ref value.Id.Value);
    }
    public static void Serialize(this IBitStream stream, ref AssetRefConfigAssets value) {
      stream.Serialize(ref value.Id.Value);
    }
    public static void Serialize(this IBitStream stream, ref AssetRefGameConfig value) {
      stream.Serialize(ref value.Id.Value);
    }
    public static void Serialize(this IBitStream stream, ref AssetRefTurnConfig value) {
      stream.Serialize(ref value.Id.Value);
    }
    public static void Serialize(this IBitStream stream, ref AssetRefUserMap value) {
      stream.Serialize(ref value.Id.Value);
    }
  }
  [System.SerializableAttribute()]
  public unsafe partial class BallPoolSpec : AssetObject {
  }
  [System.SerializableAttribute()]
  public unsafe partial class ConfigAssets : AssetObject {
  }
  [System.SerializableAttribute()]
  public unsafe partial class GameConfig : AssetObject {
  }
  [System.SerializableAttribute()]
  public unsafe partial class UserMap : AssetObject {
  }
  [System.SerializableAttribute()]
  public unsafe partial class TurnConfig : AssetObject {
  }
  public unsafe partial class ComponentPrototypeVisitor : Prototypes.ComponentPrototypeVisitorBase {
    public virtual void Visit(Prototypes.BallFields_Prototype prototype) {
      VisitFallback(prototype);
    }
  }
  public static unsafe partial class Constants {
    public const Int32 MAX_PLAYERS = 2;
  }
  public static unsafe partial class StaticDelegates {
    public static FrameSerializer.Delegate SerializeBallPoolPlayer;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitGen() {
      SerializeBallPoolPlayer = Quantum.BallPoolPlayer.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
  }
  public unsafe partial class TypeRegistry {
    partial void AddGenerated() {
      Register(typeof(AssetGuid), AssetGuid.SIZE);
      Register(typeof(Quantum.AssetRefBallPoolSpec), Quantum.AssetRefBallPoolSpec.SIZE);
      Register(typeof(AssetRefCharacterController2DConfig), AssetRefCharacterController2DConfig.SIZE);
      Register(typeof(AssetRefCharacterController3DConfig), AssetRefCharacterController3DConfig.SIZE);
      Register(typeof(Quantum.AssetRefConfigAssets), Quantum.AssetRefConfigAssets.SIZE);
      Register(typeof(AssetRefEntityPrototype), AssetRefEntityPrototype.SIZE);
      Register(typeof(AssetRefEntityView), AssetRefEntityView.SIZE);
      Register(typeof(Quantum.AssetRefGameConfig), Quantum.AssetRefGameConfig.SIZE);
      Register(typeof(AssetRefMap), AssetRefMap.SIZE);
      Register(typeof(AssetRefNavMesh), AssetRefNavMesh.SIZE);
      Register(typeof(AssetRefNavMeshAgentConfig), AssetRefNavMeshAgentConfig.SIZE);
      Register(typeof(AssetRefPhysicsMaterial), AssetRefPhysicsMaterial.SIZE);
      Register(typeof(AssetRefPolygonCollider), AssetRefPolygonCollider.SIZE);
      Register(typeof(AssetRefTerrainCollider), AssetRefTerrainCollider.SIZE);
      Register(typeof(Quantum.AssetRefTurnConfig), Quantum.AssetRefTurnConfig.SIZE);
      Register(typeof(Quantum.AssetRefUserMap), Quantum.AssetRefUserMap.SIZE);
      Register(typeof(Quantum.BallFields), Quantum.BallFields.SIZE);
      Register(typeof(Quantum.BallPoolPlayer), Quantum.BallPoolPlayer.SIZE);
      Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      Register(typeof(Quantum.BitSet2), Quantum.BitSet2.SIZE);
      Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      Register(typeof(Button), Button.SIZE);
      Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      Register(typeof(EntityRef), EntityRef.SIZE);
      Register(typeof(FP), FP.SIZE);
      Register(typeof(FPBounds2), FPBounds2.SIZE);
      Register(typeof(FPBounds3), FPBounds3.SIZE);
      Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      Register(typeof(FPVector2), FPVector2.SIZE);
      Register(typeof(FPVector3), FPVector3.SIZE);
      Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      Register(typeof(HingeJoint), HingeJoint.SIZE);
      Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      Register(typeof(Hit), Hit.SIZE);
      Register(typeof(Hit3D), Hit3D.SIZE);
      Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      Register(typeof(Quantum.InputButtons), 4);
      Register(typeof(Joint), Joint.SIZE);
      Register(typeof(Joint3D), Joint3D.SIZE);
      Register(typeof(LayerMask), LayerMask.SIZE);
      Register(typeof(MapEntityId), MapEntityId.SIZE);
      Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      Register(typeof(NullableFP), NullableFP.SIZE);
      Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      Register(typeof(PlayerRef), PlayerRef.SIZE);
      Register(typeof(Ptr), Ptr.SIZE);
      Register(typeof(QBoolean), QBoolean.SIZE);
      Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      Register(typeof(RNGSession), RNGSession.SIZE);
      Register(typeof(Shape2D), Shape2D.SIZE);
      Register(typeof(Shape3D), Shape3D.SIZE);
      Register(typeof(SpringJoint), SpringJoint.SIZE);
      Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      Register(typeof(Transform2D), Transform2D.SIZE);
      Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      Register(typeof(Transform3D), Transform3D.SIZE);
      Register(typeof(Quantum.TurnData), Quantum.TurnData.SIZE);
      Register(typeof(Quantum.TurnEndReason), 4);
      Register(typeof(Quantum.TurnStatus), 4);
      Register(typeof(Quantum.TurnType), 4);
      Register(typeof(View), View.SIZE);
      Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
  }
  public unsafe partial class FramePrinterGen {
    public static void EnsureNotStripped() {
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AssetRefBallPoolSpec>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AssetRefConfigAssets>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AssetRefGameConfig>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AssetRefTurnConfig>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AssetRefUserMap>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.TurnEndReason>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.TurnStatus>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.TurnType>();
    }
  }
}
namespace Quantum.Prototypes {
  using System;
  using System.Collections.Generic;
  using System.Runtime.InteropServices;
  using Photon.Deterministic;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Optional = Quantum.Inspector.OptionalAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  
  [System.SerializableAttribute()]
  [Prototype(typeof(TurnEndReason))]
  public unsafe partial struct TurnEndReason_Prototype {
    public Int32 Value;
    public static implicit operator TurnEndReason(TurnEndReason_Prototype value) {
        return (TurnEndReason)value.Value;
    }
    public static implicit operator TurnEndReason_Prototype(TurnEndReason value) {
        return new TurnEndReason_Prototype() { Value = (Int32)value };
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(TurnStatus))]
  public unsafe partial struct TurnStatus_Prototype {
    public Int32 Value;
    public static implicit operator TurnStatus(TurnStatus_Prototype value) {
        return (TurnStatus)value.Value;
    }
    public static implicit operator TurnStatus_Prototype(TurnStatus value) {
        return new TurnStatus_Prototype() { Value = (Int32)value };
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(TurnType))]
  public unsafe partial struct TurnType_Prototype {
    public Int32 Value;
    public static implicit operator TurnType(TurnType_Prototype value) {
        return (TurnType)value.Value;
    }
    public static implicit operator TurnType_Prototype(TurnType value) {
        return new TurnType_Prototype() { Value = (Int32)value };
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(InputButtons))]
  public unsafe partial struct InputButtons_Prototype {
    public Int32 Value;
    public static implicit operator InputButtons(InputButtons_Prototype value) {
        return (InputButtons)value.Value;
    }
    public static implicit operator InputButtons_Prototype(InputButtons value) {
        return new InputButtons_Prototype() { Value = (Int32)value };
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(BallFields))]
  public sealed unsafe partial class BallFields_Prototype : ComponentPrototype<BallFields> {
    public FPVector2 Spin;
    public Int32 Number;
    public QBoolean Striped;
    public AssetRefBallPoolSpec Spec;
    public QBoolean InTable;
    partial void MaterializeUser(Frame frame, ref BallFields result, in PrototypeMaterializationContext context);
    public override Boolean AddToEntity(FrameBase f, EntityRef entity, in PrototypeMaterializationContext context) {
      BallFields component = default;
      Materialize((Frame)f, ref component, in context);
      return f.Set(entity, component) == SetResult.ComponentAdded;
    }
    public void Materialize(Frame frame, ref BallFields result, in PrototypeMaterializationContext context) {
      result.InTable = this.InTable;
      result.Number = this.Number;
      result.Spec = this.Spec;
      result.Spin = this.Spin;
      result.Striped = this.Striped;
      MaterializeUser(frame, ref result, in context);
    }
    public override void Dispatch(ComponentPrototypeVisitorBase visitor) {
      ((ComponentPrototypeVisitor)visitor).Visit(this);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(BallPoolPlayer))]
  public sealed unsafe partial class BallPoolPlayer_Prototype : StructPrototype {
    public PlayerRef Ref;
    public TurnData_Prototype TurnStats;
    public QBoolean StripedBalls;
    partial void MaterializeUser(Frame frame, ref BallPoolPlayer result, in PrototypeMaterializationContext context);
    public void Materialize(Frame frame, ref BallPoolPlayer result, in PrototypeMaterializationContext context) {
      result.Ref = this.Ref;
      result.StripedBalls = this.StripedBalls;
      this.TurnStats.Materialize(frame, ref result.TurnStats, in context);
      MaterializeUser(frame, ref result, in context);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(Input))]
  public sealed unsafe partial class Input_Prototype : StructPrototype {
    public FPVector3 Direction;
    public FP ForceBarMarkPos;
    public FPVector2 BallPosition;
    partial void MaterializeUser(Frame frame, ref Input result, in PrototypeMaterializationContext context);
    public void Materialize(Frame frame, ref Input result, in PrototypeMaterializationContext context) {
      result.BallPosition = this.BallPosition;
      result.Direction = this.Direction;
      result.ForceBarMarkPos = this.ForceBarMarkPos;
      MaterializeUser(frame, ref result, in context);
    }
  }
  [System.SerializableAttribute()]
  [Prototype(typeof(TurnData))]
  public sealed unsafe partial class TurnData_Prototype : StructPrototype {
    public PlayerRef Player;
    public MapEntityId Entity;
    public AssetRefTurnConfig ConfigRef;
    public TurnType_Prototype Type;
    public TurnStatus_Prototype Status;
    public Int32 Number;
    public Int32 Ticks;
    partial void MaterializeUser(Frame frame, ref TurnData result, in PrototypeMaterializationContext context);
    public void Materialize(Frame frame, ref TurnData result, in PrototypeMaterializationContext context) {
      result.ConfigRef = this.ConfigRef;
      PrototypeValidator.FindMapEntity(this.Entity, in context, out result.Entity);
      result.Number = this.Number;
      result.Player = this.Player;
      result.Status = this.Status;
      result.Ticks = this.Ticks;
      result.Type = this.Type;
      MaterializeUser(frame, ref result, in context);
    }
  }
  public unsafe partial class FlatEntityPrototypeContainer {
    [ArrayLength(0, 1)]
    public List<Prototypes.BallFields_Prototype> BallFields;
    partial void CollectGen(List<ComponentPrototype> target) {
      Collect(BallFields, target);
    }
    public unsafe partial class StoreVisitor {
      public override void Visit(Prototypes.BallFields_Prototype prototype) {
        Storage.Store(prototype, ref Storage.BallFields);
      }
    }
  }
}
#pragma warning restore 0649
#pragma warning restore 1522
#pragma warning restore 0414
#pragma warning restore 0219
#pragma warning restore 0109
